import Backdrop from"../../../src/util/backdrop";import{getTransitionDurationFromElement}from"../../../src/util/index";import{clearFixture,getFixture}from"../../helpers/fixture";const CLASS_BACKDROP=".modal-backdrop",CLASS_NAME_FADE="fade",CLASS_NAME_SHOW="show";describe("Backdrop",()=>{let e;beforeAll(()=>{e=getFixture()}),afterEach(()=>{clearFixture();document.querySelectorAll(CLASS_BACKDROP).forEach(e=>{e.remove()})}),describe("show",()=>{it('if it is "shown", should append the backdrop html once, on show, and contain "show" class',e=>{const t=new Backdrop({isVisible:!0,isAnimated:!1}),o=()=>document.querySelectorAll(CLASS_BACKDROP);expect(o().length).toEqual(0),t.show(),t.show(()=>{expect(o().length).toEqual(1),o().forEach(e=>{expect(e.classList.contains("show")).toEqual(!0)}),e()})}),it('if it is not "shown", should not append the backdrop html',e=>{const t=new Backdrop({isVisible:!1,isAnimated:!0}),o=()=>document.querySelectorAll(CLASS_BACKDROP);expect(o().length).toEqual(0),t.show(()=>{expect(o().length).toEqual(0),e()})}),it('if it is "shown" and "animated", should append the backdrop html once, and contain "fade" class',e=>{const t=new Backdrop({isVisible:!0,isAnimated:!0}),o=()=>document.querySelectorAll(CLASS_BACKDROP);expect(o().length).toEqual(0),t.show(()=>{expect(o().length).toEqual(1),o().forEach(e=>{expect(e.classList.contains("fade")).toEqual(!0)}),e()})})}),describe("hide",()=>{it("should remove the backdrop html",e=>{const t=new Backdrop({isVisible:!0,isAnimated:!0}),o=()=>document.body.querySelectorAll(CLASS_BACKDROP);expect(o().length).toEqual(0),t.show(()=>{expect(o().length).toEqual(1),t.hide(()=>{expect(o().length).toEqual(0),e()})})}),it('should remove "show" class',e=>{const t=new Backdrop({isVisible:!0,isAnimated:!0}),o=t._getElement();t.show(),t.hide(()=>{expect(o.classList.contains("show")).toEqual(!1),e()})}),it('if it is not "shown", should not try to remove Node on remove method',e=>{const t=new Backdrop({isVisible:!1,isAnimated:!0}),o=()=>document.querySelectorAll(CLASS_BACKDROP),i=spyOn(t,"dispose").and.callThrough();expect(o().length).toEqual(0),expect(t._isAppended).toEqual(!1),t.show(()=>{t.hide(()=>{expect(o().length).toEqual(0),expect(i).not.toHaveBeenCalled(),expect(t._isAppended).toEqual(!1),e()})})}),it("should not error if the backdrop no longer has a parent",t=>{e.innerHTML='<div id="wrapper"></div>';const o=e.querySelector("#wrapper"),i=new Backdrop({isVisible:!0,isAnimated:!0,rootElement:o});i.show(()=>{o.remove(),i.hide(()=>{expect(document.querySelectorAll(CLASS_BACKDROP).length).toEqual(0),t()})})})}),describe("click callback",()=>{it("it should execute callback on click",e=>{const t=jasmine.createSpy("spy"),o=new Backdrop({isVisible:!0,isAnimated:!1,clickCallback:()=>t()});o.show(()=>{const o=document.createEvent("MouseEvents");o.initEvent("mousedown",!0,!0),document.querySelector(CLASS_BACKDROP).dispatchEvent(o),setTimeout(()=>{expect(t).toHaveBeenCalled(),e()},10)})})}),describe("animation callbacks",()=>{it("if it is animated, should show and hide backdrop after counting transition duration",e=>{const t=new Backdrop({isVisible:!0,isAnimated:!0}),o=jasmine.createSpy("spy2");t.show(o),t.hide(()=>{o(),setTimeout(()=>{expect(o).toHaveBeenCalledTimes(2),e()},10)}),expect(o).not.toHaveBeenCalled()}),it("if it is not animated, should show and hide backdrop without delay",e=>{const t=jasmine.createSpy("spy",getTransitionDurationFromElement),o=new Backdrop({isVisible:!0,isAnimated:!1}),i=jasmine.createSpy("spy2");o.show(i),o.hide(i),setTimeout(()=>{expect(i).toHaveBeenCalled(),expect(t).not.toHaveBeenCalled(),e()},10)}),it('if it is not "shown", should not call delay callbacks',e=>{const t=new Backdrop({isVisible:!1,isAnimated:!0}),o=jasmine.createSpy("spy",getTransitionDurationFromElement);t.show(),t.hide(()=>{expect(o).not.toHaveBeenCalled(),e()})})}),describe("Config",()=>{describe("rootElement initialization",()=>{it('Should be appended on "document.body" by default',e=>{const t=new Backdrop({isVisible:!0});t.show(()=>{expect(document.querySelector(CLASS_BACKDROP).parentElement).toEqual(document.body),e()})}),it("Should find the rootElement if passed as a string",e=>{const t=new Backdrop({isVisible:!0,rootElement:"body"});t.show(()=>{expect(document.querySelector(CLASS_BACKDROP).parentElement).toEqual(document.body),e()})}),it("Should appended on any element given by the proper config",t=>{e.innerHTML=['<div id="wrapper">',"</div>"].join("");const o=e.querySelector("#wrapper"),i=new Backdrop({isVisible:!0,rootElement:o});i.show(()=>{expect(document.querySelector(CLASS_BACKDROP).parentElement).toEqual(o),t()})})}),describe("ClassName",()=>{it("Should be able to have different classNames than default",e=>{const t=new Backdrop({isVisible:!0,className:"foo"});t.show(()=>{expect(document.querySelector(".foo")).toEqual(t._getElement()),t.dispose(),e()})})})})});