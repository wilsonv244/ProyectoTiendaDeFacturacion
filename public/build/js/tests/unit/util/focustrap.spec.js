import FocusTrap from"../../../src/util/focustrap";import EventHandler from"../../../src/dom/event-handler";import SelectorEngine from"../../../src/dom/selector-engine";import{clearFixture,getFixture,createEvent}from"../../helpers/fixture";describe("FocusTrap",()=>{let e;beforeAll(()=>{e=getFixture()}),afterEach(()=>{clearFixture()}),describe("activate",()=>{it("should autofocus itself by default",()=>{e.innerHTML='<div id="focustrap" tabindex="-1"></div>';const t=e.querySelector("div");spyOn(t,"focus");new FocusTrap({trapElement:t}).activate(),expect(t.focus).toHaveBeenCalled()}),it("if configured not to autofocus, should not autofocus itself",()=>{e.innerHTML='<div id="focustrap" tabindex="-1"></div>';const t=e.querySelector("div");spyOn(t,"focus");new FocusTrap({trapElement:t,autofocus:!1}).activate(),expect(t.focus).not.toHaveBeenCalled()}),it("should force focus inside focus trap if it can",t=>{e.innerHTML=['<a href="#" id="outside">outside</a>','<div id="focustrap" tabindex="-1">','   <a href="#" id="inside">inside</a>',"</div>"].join("");const n=e.querySelector("div");new FocusTrap({trapElement:n}).activate();const o=document.getElementById("inside"),i=()=>{expect(o.focus).toHaveBeenCalled(),document.removeEventListener("focusin",i),t()};spyOn(o,"focus"),spyOn(SelectorEngine,"focusableChildren").and.callFake(()=>[o]),document.addEventListener("focusin",i);const a=createEvent("focusin",{bubbles:!0});Object.defineProperty(a,"target",{value:document.getElementById("outside")}),document.dispatchEvent(a)}),it("should wrap focus around forward on tab",t=>{e.innerHTML=['<a href="#" id="outside">outside</a>','<div id="focustrap" tabindex="-1">','   <a href="#" id="first">first</a>','   <a href="#" id="inside">inside</a>','   <a href="#" id="last">last</a>',"</div>"].join("");const n=e.querySelector("div");new FocusTrap({trapElement:n}).activate();const o=document.getElementById("first"),i=document.getElementById("inside"),a=document.getElementById("last"),s=document.getElementById("outside");spyOn(SelectorEngine,"focusableChildren").and.callFake(()=>[o,i,a]),spyOn(o,"focus").and.callThrough();const c=()=>{expect(o.focus).toHaveBeenCalled(),o.removeEventListener("focusin",c),t()};o.addEventListener("focusin",c);const d=createEvent("keydown");d.key="Tab",document.dispatchEvent(d),s.focus()}),it("should wrap focus around backwards on shift-tab",t=>{e.innerHTML=['<a href="#" id="outside">outside</a>','<div id="focustrap" tabindex="-1">','   <a href="#" id="first">first</a>','   <a href="#" id="inside">inside</a>','   <a href="#" id="last">last</a>',"</div>"].join("");const n=e.querySelector("div");new FocusTrap({trapElement:n}).activate();const o=document.getElementById("first"),i=document.getElementById("inside"),a=document.getElementById("last"),s=document.getElementById("outside");spyOn(SelectorEngine,"focusableChildren").and.callFake(()=>[o,i,a]),spyOn(a,"focus").and.callThrough();const c=()=>{expect(a.focus).toHaveBeenCalled(),a.removeEventListener("focusin",c),t()};a.addEventListener("focusin",c);const d=createEvent("keydown");d.key="Tab",d.shiftKey=!0,document.dispatchEvent(d),s.focus()}),it("should force focus on itself if there is no focusable content",t=>{e.innerHTML=['<a href="#" id="outside">outside</a>','<div id="focustrap" tabindex="-1"></div>'].join("");const n=e.querySelector("div"),o=new FocusTrap({trapElement:n});o.activate();const i=()=>{expect(o._config.trapElement.focus).toHaveBeenCalled(),document.removeEventListener("focusin",i),t()};spyOn(o._config.trapElement,"focus"),document.addEventListener("focusin",i);const a=createEvent("focusin",{bubbles:!0});Object.defineProperty(a,"target",{value:document.getElementById("outside")}),document.dispatchEvent(a)})}),describe("deactivate",()=>{it("should flag itself as no longer active",()=>{const t=new FocusTrap({trapElement:e});t.activate(),expect(t._isActive).toBe(!0),t.deactivate(),expect(t._isActive).toBe(!1)}),it("should remove all event listeners",()=>{const t=new FocusTrap({trapElement:e});t.activate(),spyOn(EventHandler,"off"),t.deactivate(),expect(EventHandler.off).toHaveBeenCalled()}),it("doesn't try removing event listeners unless it needs to (in case it hasn't been activated)",()=>{const t=new FocusTrap({trapElement:e});spyOn(EventHandler,"off"),t.deactivate(),expect(EventHandler.off).not.toHaveBeenCalled()})})});